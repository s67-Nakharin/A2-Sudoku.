int gridSize = 9;
int cellSize = 80; 
int boardSize = gridSize * cellSize;
int selectedX = -1;
int selectedY = -1;
int[][] board = new int[gridSize][gridSize];
boolean showGame = false;
boolean[][] visible = new boolean[gridSize][gridSize];
boolean isLoading = false;
boolean[][] isInvalid = new boolean[gridSize][gridSize];
String fileName = "boardData.txt";

void setup() {
  size(720, 900);
  fillBoard();
  fillVisible();
}

void draw() {
  if (showGame) {
    drawGrid();
  } else {
    drawStartScreen();
  }
}

void drawStartScreen() {
  background(255);
  
  fill(0);
  textSize(64);
  textAlign(CENTER, CENTER);
  text("Sudoku by nkr", width / 2, height / 4);

  fill(200);
  rect(width / 2 - 125, height / 2 - 100, 250, 100);
  
  fill(0);
  textSize(48);
  textAlign(CENTER, CENTER);
  text("New Game", width / 2, height / 2 - 50);

  fill(200);
  rect(width / 2 - 125, height / 2 + 50, 250, 100);

  fill(0);
  textSize(48);
  textAlign(CENTER, CENTER);
  text("Load Save", width / 2, height / 2 + 100);
}

void drawGrid() {
  background(255);

  for (int row = 0; row < gridSize; row++) {
    for (int col = 0; col < gridSize; col++) {
      if (isInvalid[row][col]) {
        fill(255, 0, 0);  // ไฮไลต์ด้วยสีแดงเมื่อช่องผิด
      } else if (row == selectedY && col == selectedX) {
        fill(200); 
      } else {
        fill(255);
      }
      strokeWeight(1);
      rect(col * cellSize, row * cellSize, cellSize, cellSize);

      if (visible[row][col]) { 
        fill(0);
        textSize(32);
        textAlign(CENTER, CENTER);
        text(board[row][col], col * cellSize + cellSize / 2, row * cellSize + cellSize / 2 + 5);
      }
    }
  }

  for (int i = 0; i <= gridSize; i++) {
    if (i % 3 == 0) {
      strokeWeight(4);
      line(i * cellSize, 0, i * cellSize, boardSize);
      line(0, i * cellSize, boardSize, i * cellSize);
    }
  }

  fill(0);
  textSize(32);
  textAlign(CENTER, CENTER);
  text("Attempts: ", width / 2, boardSize + 20);

  fill(200);
  rect(width / 2 - 125, boardSize + 60, 250, 100);
  fill(0);
  textSize(48);
  textAlign(CENTER, CENTER);
  text("Save Game", width / 2, boardSize + 110);
}


void mousePressed() {
  if (!showGame) {
    // Handle the start screen buttons
    if (mouseX > width / 2 - 125 && mouseX < width / 2 + 125 && mouseY > height / 2 - 100 && mouseY < height / 2) {
      // New Game button
      showGame = true;
      fillBoard();
      fillVisible();
    } else if (mouseX > width / 2 - 125 && mouseX < width / 2 + 125 && mouseY > height / 2 + 50 && mouseY < height / 2 + 150) {
      // Load Save button
      loadBoard();
      isLoading = true;
      showGame = true;
    }
  } else {
    int col = mouseX / cellSize;
    int row = mouseY / cellSize;

    // Check if the selected cell is within the grid and is not already visible
    if (col < gridSize && row < gridSize && !visible[row][col]) {
      selectedX = col;
      selectedY = row;
    }

    // Save button
    if (mouseX > width / 2 - 125 && mouseX < width / 2 + 125 && mouseY > boardSize + 60 && mouseY < boardSize + 160) {
      saveBoard();
    }
  }
}


void keyPressed() {
  if (selectedX != -1 && selectedY != -1 && !visible[selectedY][selectedX]) {
    int num = key - '0';  // แปลงจาก char เป็นตัวเลข
    if (num >= 1 && num <= 9) {
      // ตรวจสอบว่าตัวเลขถูกต้องตามกฎ Sudoku หรือไม่
      if (isValid(num, selectedY, selectedX)) {
        board[selectedY][selectedX] = num;  // ถ้า valid ใส่เลขลงไป
        visible[selectedY][selectedX] = true;  // และทำให้ช่องนี้ถูกแสดง
        isInvalid[selectedY][selectedX] = false;  // เคลียร์ไฮไลต์สีแดงถ้าเลขถูกต้อง
        drawGrid();  // รีเฟรชกริดเพื่อแสดงเลขที่ใส่ใหม่
      } else {
        println("Invalid number!");  // แสดงข้อความว่าตัวเลขไม่ถูกต้อง
        isInvalid[selectedY][selectedX] = true;  // ไฮไลต์สีแดงช่องที่ผิด
        drawGrid();  // รีเฟรชกริดเพื่อแสดงไฮไลต์สีแดง
      }
    }
  }
}





void highlightInvalidCell() {
  fill(255, 0, 0);  // สีแดง
  rect(selectedX * cellSize, selectedY * cellSize, cellSize, cellSize);
  delay(500);  // รอ 500ms เพื่อแสดงสีแดง แล้วกลับไปเป็นสีเดิม
  drawGrid();  // รีเฟรชกริดใหม่เพื่อคืนค่าเป็นสีปกติ
}



void fillBoard() {
  int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  fillBoard(0, 0, numbers);
}

boolean fillBoard(int row, int col, int[] numbers) {
  if (row == gridSize) {
    return true;
  }

  if (col == gridSize) {
    return fillBoard(row + 1, 0, numbers);
  }

  if (board[row][col] != 0) {
    return fillBoard(row, col + 1, numbers);
  }

  shuffleArray(numbers);

  for (int num : numbers) {
    if (isValid(num, row, col)) {
      board[row][col] = num;
      if (fillBoard(row, col + 1, numbers)) {
        return true;
      }
      board[row][col] = 0;
    }
  }
  return false;
}

void fillVisible() {
  if (!isLoading) {
    for (int row = 0; row < gridSize; row++) {
      for (int col = 0; col < gridSize; col++) {
        visible[row][col] = random(1) < 0.8;
      }
    }
  }
}

void shuffleArray(int[] array) {
  for (int i = array.length - 1; i > 0; i--) {
    int index = (int) random(i + 1);
    int temp = array[index];
    array[index] = array[i];
    array[i] = temp;
  }
}

boolean isValid(int num, int row, int col) {
  // ตรวจสอบในแถว
  for (int i = 0; i < gridSize; i++) {
    if (board[row][i] == num && i != col) {
      return false;  // ถ้าตัวเลขอยู่ในแถวเดียวกัน แต่เป็นตำแหน่งอื่น
    }
  }

  // ตรวจสอบในคอลัมน์
  for (int i = 0; i < gridSize; i++) {
    if (board[i][col] == num && i != row) {
      return false;  // ถ้าตัวเลขอยู่ในคอลัมน์เดียวกัน แต่เป็นตำแหน่งอื่น
    }
  }

  // ตรวจสอบในบล็อกย่อย 3x3
  int boxRowStart = (row / 3) * 3;
  int boxColStart = (col / 3) * 3;
  for (int i = boxRowStart; i < boxRowStart + 3; i++) {
    for (int j = boxColStart; j < boxColStart + 3; j++) {
      if (board[i][j] == num && (i != row || j != col)) {
        return false;  // ถ้าตัวเลขอยู่ในบล็อก 3x3 แต่เป็นตำแหน่งอื่น
      }
    }
  }

  return true;  // ถ้าตัวเลขนี้สามารถใส่ได้ในตำแหน่งที่เลือก
}


void saveBoard() {
  PrintWriter output = createWriter(fileName);
  

  for (int i = 0; i < gridSize; i++) {
    for (int j = 0; j < gridSize; j++) {
      output.print(board[i][j]);
      if (j < gridSize - 1) {
        output.print(",");
      }
    }
    output.println();
  }
  

  for (int i = 0; i < gridSize; i++) {
    for (int j = 0; j < gridSize; j++) {
      output.print(visible[i][j] ? "1" : "0");
      if (j < gridSize - 1) {
        output.print(",");
      }
    }
    output.println();
  }

  output.close();
  println("Board saved to " + fileName);
}

void loadBoard() {
  String[] lines = loadStrings(fileName);

  if (lines != null && lines.length >= 2) {

    for (int i = 0; i < gridSize; i++) {
      String[] values = lines[i].split(",");
      for (int j = 0; j < gridSize; j++) {
        board[i][j] = int(values[j]);
      }
    }

    for (int i = 0; i < gridSize; i++) {
      String[] values = lines[i + gridSize].split(",");
      for (int j = 0; j < gridSize; j++) {
        visible[i][j] = values[j].equals("1");
      }
    }
    
    isLoading = false;
    println("Board loaded from " + fileName);
  } else {
    println("Failed to load board or incorrect file format.");
  }
}
